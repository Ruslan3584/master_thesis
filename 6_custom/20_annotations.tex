\section{Алгоритм розв'язку $(\max,+)$ задач розмітки}

Використовуючи приведені алгоритми у якості блоків, побудуємо покращений 
end-to-end алгоритм розв'язку $(\max,+)$ задач розмітки із цілочисельними якостями.

Нехай $T$ --- множина об'єктів, $K$ --- множина міток, $\Gamma \subset T^2$ --- структура сусідства, 
$N_t$ --- множина сусідів об'єкту $t\in T$. Маємо цілочисельні якості вершин та ребер
$q_t(k)\in \mathbb{Z}$, $t\in T$, $k\in K$, і $g_{tt'}(k,k')\in \mathbb{Z}$, $tt'\in\Gamma$, $k\in K$, $k'\in K$.
Відмітимо, що цілочисельність якостей --- не є великим обмеженням на практиці, так як всі обчислювальні машини
мають граничну точність. Візьмемо константу $\varepsilon$, причому $\varepsilon\in\mathbb{R_+}$ --- міра допустимого 
відхилення від оптимального значення цільової функції, а також поелементне відхилення розмітки від оптимальної.
Спочатку методом субградієнтного спуску виконуємо оптимізацію цільової функції двоїстої задачі $G(\varphi)$ до тих пір, поки алгоритм
викреслення другого порядку не надасть не нульові мітки, тобто буде відомо, що 
для даної репараметризації існує допустима розмітка. Застосовуємо субградієнтний 
спуск до цільової функції за аргументом $\varphi$ та отримаємо послідовність
репараметризацій $(\varphi^j:j\in\mathbb{N}_0)$. Робимо мінімальну кількість кроків до виконання умови існування розмітки.
Зупиняємо роботу субградієнтний спуску на найменшому номері $i\in\mathbb{N}_0$ кроку, 
за якого для $q^{\varphi^i}$ і $g^{\varphi^i}$ існує $\varepsilon$-узгоджений набір вершин та ребер.
Результат застосування цієї процедури для обраних $q$, $g$ і $\varepsilon$ позначимо
\begin{equation*}
    \phi(q,g;\varepsilon)=\varphi^i.
\end{equation*}
Такий номер $i$ обов'язково знайдеться, адже відомо, що для будь-якого 
$\varepsilon\in\mathbb{R_+}$ субградієнтний спуск за скінченну кількість $i\in\mathbb{N}_0$ кроків
дійде до такого значення $\varphi^i$, за якого існує $\varepsilon$-узгоджений набір вершин та ребер \cite{lopatka_stop_cond}.

Пошук однієї з найкращих розміток здійснюють у такий спосіб.
\begin{enumerate}
    \item Ініціалізуємо початкові значення якостей вершин, введемо функцію $q^0=q$ та номер кроку $j=0$.
    \item Якщо кожен об'єкт $t\in T$ має лише по одній мітці зі скінченною якістю, алгоритм завершується, 
    а розмітку $k^*$ будують у такий спосіб, що
    \begin{equation*}
        q^j_t(k^*_t)>-\infty, \forall t\in T.
    \end{equation*}
    \item Якщо ж тривіального рішення не існує, продовжуємо алгоритм. Для довільного
    об'єкта $t\in T$, у якому залишилося більше однієї мітки зі скінченною вагою, фіксуємо довільну мітку $k\in K$.
    Функцію якостей ребер залишаємо, а функцію якостей вершин змінимо таким чином, щоб в об'єкті $t\in T$ залишилася тільки 
    обрана мітка $k$. Позначимо функцію $q':T\times K\rightarrow\mathbb{R}\cup\{-\infty\}$, 
    яка в об'єкті $t$ забороняє усі мітки окрім $k$
    \begin{equation*}
        q'_{t'}(k') =
        \begin{cases}
            -\infty, & t'=t, k' \neq k,\\
            q^j_{t'}(k'), & \text{інакше.}
        \end{cases}
    \end{equation*}
    Якщо подана на вхід алгоритму задача була супермодулярною, то така модифікація якостей вершин
    залишить задачу супермодулярною, адже визначення супермодулярності не накладає обмежень на якості вершин.
    \item Виконуємо субградієнтний спуск, доки не отримаємо $\varepsilon$-узгоджений 
    набір вершин та ребер, для пошуку значення $E(q',g;\phi(q',g,\varepsilon))$. Якщо виконується рівність
    \begin{equation*}
        \lfloor E(q',g;\phi(q',g,\varepsilon))\rfloor = \lfloor E(q,g;\phi(q,g,\varepsilon))\rfloor, 
    \end{equation*}
    то переходимо на наступну ітерацію $j=j+1$, створюємо функцію $q^j=q'$ (яка 
    забороняє в об'єкті $t\in T$ усі мітки окрім обраної мітки $k\in K$) та повертаємося до другого кроку
    (перевірка на те, чи завершився алгоритм). Якщо отриманий результат менший за той, що був отриманий до початку 
    роботи алгоритму пошуку розмітки, тобто
    \begin{equation*}
        \lfloor E(q',g;\phi(q',g,\varepsilon))\rfloor < \lfloor E(q,g;\phi(q,g,\varepsilon))\rfloor, 
    \end{equation*}
    завершуємо алгоритм із відповіддю ``задача не є супермодулярною'', тому що
    було доведено, що у випадку супермодулярної задачі значення $E(q,g;\phi(q,g,\varepsilon))$ дорівнює 
    вазі $G(k^*)$ оптимальної розмітки $k^*$, а наведена нерівність означатиме, що під час роботи алгоритму може бути знайдена 
    розмітка із меншою вагою. Якщо отриманий результат більший за той, що був отриманий до початку роботи алгоритму пошуку розмітки
    \begin{equation*}
        \lfloor E(q',g;\phi(q',g,\varepsilon))\rfloor > \lfloor E(q,g;\phi(q,g,\varepsilon))\rfloor, 
    \end{equation*}
    виконуємо третій крок алгоритму для іншої мітки $k\in K$ (яку не було обрано раніше у даному об'єкті).
    Якщо ця нерівність виконується для всіх міток в об'єкті, то завершуємо алгоритм із 
    відповіддю ``задача не є супермодулярною''
    , тому що за умови супермодулярності задачі обов'язково можна знайти мітку, що
    належить оптимальній розмітці, якість якої дорівнює $\lfloor E(q,g;\phi(q,g,\varepsilon))\rfloor$.
\end{enumerate}

При такій постановці, даний алгоритм потребує не більше ніж $|T|\cdot|K|$ розрахунків величин 
$\lfloor E(q,g;\phi(q,g,\varepsilon))\rfloor$ (які ми здійснюємо за допомогою субградієнтного спуску) для різних значень $q'$.
Наведену оцінку складності можна покращити, якщо на етапі пошуку мітки використати алгоритм двійкового пошуку.

\subsection{Алгоритм двійкового пошуку}

Двійковий пошук --- класичний та ефективний алгоритм пошуку елементів у відсортованому масиві.
Основний принцип роботи полягає у багаторазовому поділу половини масиву, яка може містити потрібний 
елемент, до тих пір, поки список можливих місць не звузиться лише до одного.
Двійковий пошук є суттєво швидшим за лінійний, може використовуватися для широкого ряду задач, також він відносно простий у реалізації і на сьогодні є
загальновживаним. В найгіршому випадку двійковий пошук працює за логарифмічний час, роблячи $\mathcal{O}(\log n)$ 
порівнянь елементів, де $n$ --- розмір вхідного масиву.

Якщо розглядати двійковий пошук для пошуку числа у відсортованому масиві, то схематично алгоритм
буде виглядати наступним чином:\\
\textbf{Вхід:} $A$ --- масив впорядкованих чисел довжиною $n\in\mathbb{N}_+$, $x$ --- шуканий елемент.\\
\textbf{Вихід:} індекс $i:0\leq i < n$, такий що $A[i]=x$ або $-1$, якщо елемента $x$ в масиві немає.
\begin{enumerate}
    \item Порівнюємо $x$ із середнім елементом масиву $A$, якщо не співпадає і $len(A)=1$, то повертаємо $-1$.
    \item Якщо співпадає, то завершуємо алгоритм, повертаємо індекс середини масиву.
    \item Якщо $x$ більше за середній елемент, то $x$ може лежати лише в правій частині масиву $A$. Рекурсивно запускаємо процедуру для правої частини.
    \item Якщо $x$ менше за середній елемент, то повторюємо процедуру рекурсивно для лівої частини масиву $A$. 
\end{enumerate}

Двійковий пошук може робити набагато більше, ніж просто знайти значення в масиві чисел. Його можна використовувати 
скрізь, де існує монотонна функція, яка приймає значення істинна або хиба.
Припустимо, що $f(x)$ --- булева функція, яка приймає значення $0$ або $1$.
Двійковий пошук можна використовувати, коли булева предикатна функція $f(x)$ є
монотонною за змінною $x$, тоді двійковий пошук буде сигналізувати про перехід від 
нулів до одиничок чи навпаки. 

У контексті нашої задачі, таке застосування може бути корисним. Роль предиката буде виконувати 
алгоритм викреслювання другого порядку, а пошук буде відбуватися на скінченному масиві міток $K$.

\subsection{Застосування двійкового пошуку у самоконтролі}

На етапі пошуку мітки $k_t\in K$ для об'єкта $t\in T$ на кожній ітерації $j$
використаємо двійковий пошук: розіб'ємо множину $K$ на такі дві підмножини $K_1$ та $K_2$, що
\begin{equation*}
    \begin{cases}
        K_1\cup K_2 = K, \\
        K_1\cap K_2 = \emptyset, \\
        ||K_1|-|K_2|| \leq 1,
    \end{cases}
\end{equation*}
та введемо функцію $q'$
\begin{equation*}
    q'_{t'}(k') =
    \begin{cases}
        -\infty, & t'=t, k' \in  K_1,\\
        q^j_{t'}(k'), & \text{інакше.}
    \end{cases}
\end{equation*}
Якщо $\lfloor E(q',g;\phi(q',g,\varepsilon))\rfloor = \lfloor E(q,g;\phi(q,g,\varepsilon))\rfloor$, то шукане $k$ 
може знаходитися у $K_2$, і його треба шукати у цій множині. Якщо 
$\lfloor E(q',g;\phi(q',g,\varepsilon))\rfloor < \lfloor E(q,g;\phi(q,g,\varepsilon))\rfloor$, задача не є супермодулярною.
Якщо $\lfloor E(q',g;\phi(q',g,\varepsilon))\rfloor > \lfloor E(q,g;\phi(q,g,\varepsilon))\rfloor$, шукаємо відповідь у множині $K_1$.
Пошук у вибраній множині $K_i, i\in \{1,2\}$ виконують за тим самим принципом.
Наприкінці, коли залишається лише одне $k$, потрібно перевірити рівність 
$\lfloor E(q',g;\phi(q',g,\varepsilon))\rfloor = \lfloor E(q,g;\phi(q,g,\varepsilon))\rfloor$, 
заборонивши усі інші мітки в об'єкті, тому що, коли множина $K_1$ не підходила, ми 
одразу вибирали $K_2$, але не перевіряли, чи вона підходить. 
Отже, для наведеного алгоритму розмітки потрібно не більше ніж $|T|\cdot \log_2 |K| + 1$ 
розрахунків величин $\lfloor E(q',g;\phi(q',g,\varepsilon))\rfloor$ для різних $q'$.

\section{Властивості розв'язку}

Якщо для супермодулярної $(\max,+)$ задачі розмітки із впорядкованістю $n$ 
(яка може бути невідомою) знайшовся $\varepsilon$-узгоджений набір вершин та ребер, 
для кожної пари сусідніх об'єктів $tt'\in\Gamma$ можна обрати таке ребро 
$((t,k_t),(t',l_{t'}))\in A$ (необов'язково різні), що 
\begin{equation*}
    \begin{cases}
        n_t(k_t)\geq n_t(l_t),\\
        n_{t'}(k_{t'})\geq n_{t'}(l_{t'}),
    \end{cases}
\end{equation*}
для яких справджується нерівність 
\begin{equation*}
    g_{tt'}(k_t,k_{t'})+g_{tt'}(l_t,l_{t'})\geq g_{tt'}(k_t,l_{t'})+g_{tt'}(l_t,k_{t'}).
\end{equation*}

З визначення $\varepsilon$-узгодженості маємо нерівності
\begin{equation*}
    g_{tt'}(k_t,l_{t'})\geq \max\limits_{l\in K, l'\in K}g_{tt'}(l,l')-\varepsilon,
\end{equation*}
\begin{equation*}
    g_{tt'}(l_t,k_{t'})\geq \max\limits_{l\in K, l'\in K}g_{tt'}(l,l')-\varepsilon,
\end{equation*}
отже 
\begin{equation*}
    g_{tt'}(k_t,k_{t'})+g_{tt'}(l_t,l_{t'})\geq g_{tt'}(k_t,l_{t'})+g_{tt'}(l_t,k_{t'})\geq 2\cdot \max\limits_{l\in K, l'\in K}g_{tt'}(l,l')- 2\cdot \varepsilon.
\end{equation*}
З визначення максимального елементу маємо нерівність
\begin{equation*}
    -g_{tt'}(l_t,l_{t'})\geq -\max\limits_{l\in K, l'\in K}g_{tt'}(l,l'),
\end{equation*}
тому 
\begin{equation*}
    g_{tt'}(k_t,k_{t'})\geq \max\limits_{l\in K, l'\in K}g_{tt'}(l,l') - 2\cdot \varepsilon.
\end{equation*}
Зауважимо, що за умови
\begin{equation*}
    \max\limits_{l\in K, l'\in K}g_{tt'}(l,l') - \varepsilon > g_{tt'}(k_t,k_{t'})\geq \max\limits_{l\in K, l'\in K}g_{tt'}(l,l') - 2\cdot \varepsilon,
\end{equation*}

ребро $((t,k_t),(t',k_t'))$ не належить $\varepsilon$-узгодженому набору $A$ ребер, проте може 
належати оптимальній розмітці.

Якщо задача є супермодулярною і знайшовся $\varepsilon$-узгоджений набір вершин та ребер, існує 
така розмітка $k:T\rightarrow K$, для якої справджується вираз 
\begin{equation*}
    \begin{aligned}
        \sum_{t \in T} q_t(k_t) + \sum_{tt' \in \Gamma} g_{tt'}(k,k')=\sum_{t \in T} q^\varphi_t(k_t) + \sum_{tt' \in \Gamma} g^\varphi_{tt'}(k,k')\geq\\
        \geq \sum_{t \in T} \left( \max_{l\in K} q^\varphi_t(l) -\varepsilon \right) + \sum_{tt' \in \Gamma}  \max\limits_{l\in K, l'\in K} \left( g^\varphi_{tt'}(l,l') - 2\cdot\varepsilon \right)=\\
        = \sum_{t \in T} \max_{l\in K} q^\varphi_t(l) - |T|\cdot\varepsilon  + \sum_{tt' \in \Gamma}  \max\limits_{l\in K, l'\in K} g^\varphi_{tt'}(l,l') - 2\cdot\Gamma\cdot\varepsilon=\\
        = \sum_{t \in T} \max_{l\in K} q^\varphi_t(l) + \sum_{tt' \in \Gamma}  \max\limits_{l\in K, l'\in K} g^\varphi_{tt'}(l,l') - \left( |T|+2\cdot\Gamma \right)\cdot\varepsilon.
    \end{aligned}
\end{equation*}
Найкраща розмітка не може мати більшу якість, ніж сума найбільших значень $q$ та $g$.
Це означає, що за умови 
\begin{equation*}
    (|T|+2\cdot\Gamma)\cdot\varepsilon<1,
\end{equation*}
якість розмітки $k$ дорівнює вазі найкращої розмітки, бо функції $q$ і $g$ є цілочисельними \cite{diffusion_shlezinger}.

Якщо задача є супермодулярною та має цілочисельні якості, то наведений алгоритм пошуку розмітки надасть
оптимальну розмітку для 
\begin{equation*}
    \varepsilon \leq \frac{1}{|T|+2\cdot|\Gamma|+1}.
\end{equation*}

У загальному випадку $(\max,+)$ задачі розмітки належать класу складності 
$EXP-APX$ --- класу задач, для яких за поліноміальний від розміру вхідний даних час 
можна знайти наближення, похибка якого обмежена експонентою від розміру даних \cite{li2016complexity}.
Проте зауважимо, що у тому разі, коли задача не є супермодулярною, проте має цілочисельні якості і алгоритм надав
розмітку $k^*$, ця розмітка буде оптимальною, оскільки за побудовою алгоритму ціла частина
значення функції $E$ не змінюється і дорівнює $G(k^*)$.

\subsection{Спосіб перевірки отриманого розв'язку}

Важливою властивістю отриманого розв’язку є те, що його коректність можна
перевірити за скінченний час. Функція $\varphi$ є так званим сертифікатом цієї задачі \cite{complexity}.
Це набір чисел, розмір якого має поліноміальну залежність від розміру вхідних даних
задачі, та за допомогою якого можна перевірити коректність розв’язку за кількість
операцій, що має поліноміальну залежність від розміру вхідних даних задачі. 
Маючи $\varphi=\phi(q,g;\varepsilon)$ та $k^*$, можна легко перевірити нерівність
\begin{equation*}
    G(k^*)>E(q,g;\varphi)-1.
\end{equation*}
Справедливість цієї нерівності означає, що знайдена розмітка $k^*$ дійсно є розв’язком
поданої на вхід алгоритму $(\max,+)$ задачі розмітки з цілочисельними якостями ребер та
вершин.
