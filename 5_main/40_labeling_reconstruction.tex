\section{Відновлення розмітки після оптимізації}

Алгоритми з самоконтролем відомі для розв'язку задач лінійної
класифікації, для інваріантних відносно оператора напівгратки задач розмітки,
для інваріантних відносно мажоритарного оператора $(\min, \max)$ задач розмітки
та більш широкого класу задач розмітки, інваріантних відносно мажоритарного
оператора а також для супермодулярних $(\max,+)$
задач розмітки з цілочисельними якостями вершин та ребер.

Надалі ми будемо розглядати самоконтроль у контексті його застосування до $(\max,+)$
задач розмітки, а саме --- пошуку оптимальної розмітки після оптимізації цільової функції.

\subsection{Самоконтроль}

Для $(\max,+)$ задач розмітки самоконтроль використовується для відшукання узгодженої 
розмітки. Часто такої розмітки може не існувати, такі випадки алгоритм також відпрацьовує.
Не вдаючись в деталі, хочемо, щоб на вхід алгоритму подавали $(\bigvee, \bigwedge)$ задачу розмітки, після
оптимізації цільової функції, а на вихід одне з двох --- найкращу розмітку (якщо вона існує), або
відповідь --- для даної репараметризації не існує узгодженої розмітки.
Самоконтроль полягає у тому, що не користувач вирішує, на яке питання треба відповісти,
а сам алгоритм вирішує, що потрапляє у зону його компетентності.

У контексті $(\max,+)$ задачі пошуку $\varepsilon$-допустимої розмітки, 
задача виглядає наступним чином:
\begin{equation}
    \begin{aligned}
    k^*(\varepsilon)\in\arg\bigvee_{k:T\rightarrow K^T}\bigwedge_{tt'\in\Gamma}
    \llbracket |g^\varphi_{tt'}(k,k')-\max\limits_{l\in K, l'\in K}g^{\varphi}_{tt'}(l,l')|\leq\varepsilon\rrbracket\wedge
    \bigwedge_{t\in T}\llbracket|q^{\varphi}_t(k) - \max\limits_{l\in K}q^{\varphi}_t(l)|\leq \varepsilon\rrbracket,
\end{aligned}
\end{equation}
де $q^{\varphi}_t(k)$, $t\in T$, $k\in K$ --- репараметризовані значення якостей вершин, 
після оптимізації цільової функції, $g^\varphi_{tt'}(k,k')$, $tt'\in\Gamma$, $k\in K$, 
$k'\in K$ --- репараметризовані значення якостей ребер після оптимізації.
Нехай $f:K^T\rightarrow \{0,1\}$ --- функція допустимості розмітки, тобто якщо
$f(k)=1, k\in K^T$ --- то розмітка $k$ є допустимою, інакше --- ні. 
Тоді можна представити задачу як
\begin{equation}
    \begin{aligned}
    k^*(\varepsilon)\in\arg\bigvee_{k:T\rightarrow K^T}
    f(k_\varepsilon).
\end{aligned}
\end{equation}

Маємо алгоритм викреслювання другого порядку, який дає відповідь, чи існує
допустима розмітка для даного набору якостей вершин та ребер, 
тобто перевіряти рівність $f(k)=1$, $k\in K^T$. Самоконтроль займається тим, що
знаходить таке значення $k\in K^T$ для якого $f(k)=1$. Алгоритм викреслювання 
другого порядку є ядром самоконтролю.\\
\textbf{Вхід} \\
Задача пошуку оптимальної розмітки\\
\textbf{Вихід}\\
 Найкраща допустима розмітка $k\in K^T$ або ,,відмова від розпізнавання''
або ,,немає рішення''\\
\textbf{Ітерації}
\begin{enumerate}
    \item На першому кроці перевіримо, чи взагалі існує допустима розмітка, тобто
    \begin{equation}
    \begin{aligned}
    \begin{cases}
        \bigvee_{k:T\rightarrow K^T}f(k)=0, & \text{відповідь --- ,,немає рішення''},\\
        \bigvee_{k:T\rightarrow K^T}f(k)=1, & \text{продовжуємо роботу, переходимо до кроку №2.}
    \end{cases}
\end{aligned}
\end{equation}
\item Проходимося по всіх об'єктах і в кожному з них шукаємо мітку, при якій існує допустима розмітка
\begin{equation}
    \forall t \in T,
\end{equation}
проходимося по всіх мітках в об'єкті $t\in T$ і по черзі перевіряємо допустимість
\begin{equation}
    \forall i \in \{1,\dots, |K|\},
\end{equation}
\begin{equation}
    F_t(k_i) = \bigvee_{k_1\in K}\bigvee_{k_2\in K}\dots\bigvee_{k_{i-1}\in K}
    \bigvee_{k_{i+1}\in K}\dots\bigvee_{k_{|K|\in K}} f(k_1, k_2, \dots, k_{i-1}, k_i, k_{i+1},\dots,k_{|K|}).
\end{equation}
Якщо існує така мітка, при якій існує допустима розмітка, то запам'ятовуємо її,
\begin{equation}
   \exists k\in K: F_t(k)=1,\implies k^*_t = k.
\end{equation}
Якщо ж пройшовшись по всіх мітках в об'єкті $t\in T$ такої мітки не знайшлося, то це
означає, що задача не є супермодулярною, і розв’язок неможливий, тому відповідь 
,,відмова від розпізнавання''.
\item Якщо для кожного об'єкту знайшлася мітка, при якій існує допустима розмітка, 
завершуємо алгоритм, і повертаємо найкращу розмітку, тобто якщо виконується
\begin{equation}
    \forall t\in T,  \exists k^*_t\in K: F_t(k^*_t)=1, 
\end{equation}
то набір $k^*=(k^*_1, \dots, k^*_{|T|})$ повертаємо як відповідь.
Якщо для кожного об'єкта знайшли мітку, то в сукупності ці мітки будуть складати розмітку.
\end{enumerate}